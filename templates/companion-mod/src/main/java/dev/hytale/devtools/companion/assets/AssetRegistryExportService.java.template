package dev.hytale.devtools.companion.assets;

import com.hypixel.hytale.assetstore.AssetRegistry;
import com.hypixel.hytale.assetstore.AssetStore;
import com.hypixel.hytale.codec.EmptyExtraInfo;
import com.hypixel.hytale.codec.schema.SchemaContext;
import com.hypixel.hytale.codec.schema.config.Schema;
import com.hypixel.hytale.server.core.asset.AssetRegistryLoader;
import com.hypixel.hytale.server.core.plugin.JavaPlugin;
import com.hypixel.hytale.server.core.util.BsonUtil;
import org.bson.BsonArray;
import org.bson.BsonBoolean;
import org.bson.BsonDocument;
import org.bson.BsonInt32;
import org.bson.BsonNull;
import org.bson.BsonString;

import javax.annotation.Nonnull;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.stream.Stream;

public final class AssetRegistryExportService {
    private static final String STORES_INFO_FILE = "stores_info";
    private static final String SCHEMA_MAPPINGS_FILE = "schemaMappings";
    private static final String SCHEMAS_DIRECTORY = "Schema";
    private static final Path EXPORT_DIRECTORY = Path.of("{{COMPANION_SCHEMA_OUTPUT_PATH}}");

    private AssetRegistryExportService() {
    }

    public static void exportSnapshot(@Nonnull JavaPlugin plugin) {
        try {
            Files.createDirectories(EXPORT_DIRECTORY);

            BsonDocument vscodeConfig = new BsonDocument();
            SchemaContext schemaContext = new SchemaContext();
            Map<String, Schema> schemas = AssetRegistryLoader.generateSchemas(schemaContext, vscodeConfig);

            AssetStore<?, ?, ?>[] stores = AssetRegistry.getStoreMap().values().toArray(AssetStore[]::new);
            Arrays.sort(stores, Comparator.comparing(store -> store.getAssetClass().getSimpleName()));

            BsonArray storeArray = new BsonArray();
            int totalAssetCount = 0;
            for (AssetStore<?, ?, ?> store : stores) {
                storeArray.add(toStoreDocument(store));
                totalAssetCount += store.getAssetMap().getAssetCount();
            }

            BsonDocument storesInfo = new BsonDocument();
            storesInfo.put("storeCount", new BsonInt32(stores.length));
            storesInfo.put("totalLoadedAssets", new BsonInt32(totalAssetCount));
            storesInfo.put("stores", storeArray);

            writeJsonAndBson(STORES_INFO_FILE, storesInfo);
            writeJsonAndBson(SCHEMA_MAPPINGS_FILE, vscodeConfig);
            deleteLegacySchemasBundle();
            writeSchemas(schemas);
            plugin.getLogger().at(Level.INFO).log("Exported asset registry snapshot files to %s", EXPORT_DIRECTORY.toAbsolutePath());
        } catch (Throwable throwable) {
            plugin.getLogger().at(Level.SEVERE).withCause(throwable).log("Failed to export asset registry snapshot");
        }
    }

    private static void writeJsonAndBson(@Nonnull String baseFileName, @Nonnull BsonDocument document) {
        Path jsonPath = EXPORT_DIRECTORY.resolve(baseFileName + ".json");
        Path bsonPath = EXPORT_DIRECTORY.resolve(baseFileName + ".bson");
        BsonUtil.writeDocument(jsonPath, document, false).join();
        BsonUtil.writeDocumentBytes(bsonPath, document).join();
    }

    private static void writeSchemas(@Nonnull Map<String, Schema> schemas) throws IOException {
        Path schemaDirectory = EXPORT_DIRECTORY.resolve(SCHEMAS_DIRECTORY);
        Files.createDirectories(schemaDirectory);
        clearSchemaDirectory(schemaDirectory);

        schemas.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
            BsonDocument schemaDocument = Schema.CODEC.encode(entry.getValue(), EmptyExtraInfo.EMPTY).asDocument();
            String fileName = entry.getKey().endsWith(".json") ? entry.getKey() : entry.getKey() + ".json";
            Path jsonPath = schemaDirectory.resolve(fileName);
            Path bsonPath = schemaDirectory.resolve(fileName.replace(".json", ".bson"));
            BsonUtil.writeDocument(jsonPath, schemaDocument, false).join();
            BsonUtil.writeDocumentBytes(bsonPath, schemaDocument).join();
        });
    }

    private static void clearSchemaDirectory(@Nonnull Path schemaDirectory) throws IOException {
        try (Stream<Path> stream = Files.list(schemaDirectory)) {
            stream.filter(Files::isRegularFile)
                    .filter(path -> {
                        String fileName = path.getFileName().toString().toLowerCase();
                        return fileName.endsWith(".json") || fileName.endsWith(".bson");
                    })
                    .forEach(path -> {
                        try {
                            Files.deleteIfExists(path);
                        } catch (IOException exception) {
                            throw new RuntimeException(exception);
                        }
                    });
        }
    }

    private static void deleteLegacySchemasBundle() throws IOException {
        Files.deleteIfExists(EXPORT_DIRECTORY.resolve("schemas.json"));
        Files.deleteIfExists(EXPORT_DIRECTORY.resolve("schemas.bson"));
    }

    private static BsonDocument toStoreDocument(@Nonnull AssetStore<?, ?, ?> store) {
        BsonDocument document = new BsonDocument();
        document.put("assetClass", new BsonString(store.getAssetClass().getName()));
        document.put("assetSimpleName", new BsonString(store.getAssetClass().getSimpleName()));
        document.put("keyClass", new BsonString(store.getKeyClass().getName()));
        document.put("path", store.getPath() == null ? BsonNull.VALUE : new BsonString(store.getPath()));
        document.put("extension", new BsonString(store.getExtension()));
        document.put("codecClass", new BsonString(store.getCodec().getClass().getName()));
        document.put("assetMapClass", new BsonString(store.getAssetMap().getClass().getName()));
        document.put("assetCount", new BsonInt32(store.getAssetMap().getAssetCount()));
        document.put("unmodifiable", BsonBoolean.valueOf(store.isUnmodifiable()));

        Class<?> idProvider = store.getIdProvider();
        if (idProvider != null) {
            document.put("idProvider", new BsonString(idProvider.getName()));
        }

        BsonArray loadsAfter = new BsonArray();
        store.getLoadsAfter().stream().map(Class::getName).sorted().forEach(name -> loadsAfter.add(new BsonString(name)));
        document.put("loadsAfter", loadsAfter);

        List<?> preAddedAssets = store.getPreAddedAssets();
        int preAddedCount = preAddedAssets == null ? 0 : preAddedAssets.size();
        document.put("preAddedAssetCount", new BsonInt32(preAddedCount));
        if (preAddedAssets != null && !preAddedAssets.isEmpty()) {
            BsonArray preAddedKeys = new BsonArray();
            preAddedAssets.stream().map(asset -> keyToString(store, asset)).sorted().forEach(key -> preAddedKeys.add(new BsonString(key)));
            document.put("preAddedKeys", preAddedKeys);
        }

        return document;
    }

    @SuppressWarnings({ "rawtypes", "unchecked" })
    private static String keyToString(@Nonnull AssetStore<?, ?, ?> store, @Nonnull Object asset) {
        Function keyFunction = store.getKeyFunction();
        Object key = keyFunction.apply(asset);
        return key == null ? "null" : key.toString();
    }
}
