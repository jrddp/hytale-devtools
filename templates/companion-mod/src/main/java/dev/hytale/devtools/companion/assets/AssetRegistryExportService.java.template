package dev.hytale.devtools.companion.assets;

import com.hypixel.hytale.assetstore.AssetRegistry;
import com.hypixel.hytale.assetstore.AssetStore;
import com.hypixel.hytale.builtin.asseteditor.AssetEditorPlugin;
import com.hypixel.hytale.builtin.asseteditor.assettypehandler.AssetStoreTypeHandler;
import com.hypixel.hytale.builtin.asseteditor.assettypehandler.AssetTypeHandler;
import com.hypixel.hytale.codec.EmptyExtraInfo;
import com.hypixel.hytale.codec.schema.SchemaContext;
import com.hypixel.hytale.codec.schema.config.Schema;
import com.hypixel.hytale.protocol.packets.asseteditor.AssetEditorAssetType;
import com.hypixel.hytale.server.core.asset.AssetRegistryLoader;
import com.hypixel.hytale.server.core.plugin.JavaPlugin;
import com.hypixel.hytale.server.core.util.BsonUtil;
import org.bson.BsonArray;
import org.bson.BsonBoolean;
import org.bson.BsonDocument;
import org.bson.BsonInt32;
import org.bson.BsonNull;
import org.bson.BsonString;
import org.bson.BsonValue;

import javax.annotation.Nonnull;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.stream.Stream;

public final class AssetRegistryExportService {
    private static final String STORES_INFO_FILE = "stores_info";
    private static final String SCHEMA_MAPPINGS_FILE = "schemaMappings";
    private static final String SCHEMAS_DIRECTORY = "Schema";
    private static final Path EXPORT_DIRECTORY = Path.of("{{COMPANION_SCHEMA_OUTPUT_PATH}}");

    private AssetRegistryExportService() {
    }

    public static void exportSnapshot(@Nonnull JavaPlugin plugin) {
        try {
            Files.createDirectories(EXPORT_DIRECTORY);

            BsonDocument vscodeConfig = new BsonDocument();
            SchemaContext schemaContext = new SchemaContext();
            Map<String, Schema> schemas = AssetRegistryLoader.generateSchemas(schemaContext, vscodeConfig);

            AssetStore<?, ?, ?>[] stores = AssetRegistry.getStoreMap().values().toArray(AssetStore[]::new);
            Arrays.sort(stores, Comparator.comparing(store -> store.getAssetClass().getSimpleName()));

            BsonArray storeArray = new BsonArray();
            int totalAssetCount = 0;
            for (AssetStore<?, ?, ?> store : stores) {
                storeArray.add(toStoreDocument(store));
                totalAssetCount += store.getAssetMap().getAssetCount();
            }

            BsonArray assetTypeOnlyStores = buildAssetTypeOnlyStores();
            for (BsonValue assetTypeStore : assetTypeOnlyStores) {
                storeArray.add(assetTypeStore);
            }

            int assetRegistryStoreCount = stores.length;
            int assetTypeOnlyStoreCount = assetTypeOnlyStores.size();
            BsonDocument storesInfo = new BsonDocument();
            storesInfo.put("assetRegistryStoreCount", new BsonInt32(assetRegistryStoreCount));
            storesInfo.put("assetTypeOnlyStoreCount", new BsonInt32(assetTypeOnlyStoreCount));
            storesInfo.put("storeCount", new BsonInt32(assetRegistryStoreCount + assetTypeOnlyStoreCount));
            storesInfo.put("totalLoadedAssets", new BsonInt32(totalAssetCount));
            storesInfo.put("stores", storeArray);

            writeJson(STORES_INFO_FILE, storesInfo);
            writeJson(SCHEMA_MAPPINGS_FILE, vscodeConfig);
            deleteLegacySchemaJsonFiles();
            writeSchemas(schemas);
            plugin.getLogger().at(Level.INFO).log("Exported asset registry snapshot files to %s", EXPORT_DIRECTORY.toAbsolutePath());
        } catch (Throwable throwable) {
            plugin.getLogger().at(Level.SEVERE).withCause(throwable).log("Failed to export asset registry snapshot");
        }
    }

    private static void writeJson(@Nonnull String baseFileName, @Nonnull BsonDocument document) {
        Path jsonPath = EXPORT_DIRECTORY.resolve(baseFileName + ".json");
        BsonUtil.writeDocument(jsonPath, document, false).join();
    }

    private static void writeSchemas(@Nonnull Map<String, Schema> schemas) throws IOException {
        Path schemaDirectory = EXPORT_DIRECTORY.resolve(SCHEMAS_DIRECTORY);
        Files.createDirectories(schemaDirectory);
        clearSchemaDirectory(schemaDirectory);

        schemas.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEach(entry -> {
            BsonDocument schemaDocument = Schema.CODEC.encode(entry.getValue(), EmptyExtraInfo.EMPTY).asDocument();
            String fileName = entry.getKey().endsWith(".json") ? entry.getKey() : entry.getKey() + ".json";
            Path jsonPath = schemaDirectory.resolve(fileName);
            BsonUtil.writeDocument(jsonPath, schemaDocument, false).join();
        });
    }

    private static void clearSchemaDirectory(@Nonnull Path schemaDirectory) throws IOException {
        try (Stream<Path> stream = Files.list(schemaDirectory)) {
            stream.filter(Files::isRegularFile)
                    .filter(path -> {
                        String fileName = path.getFileName().toString().toLowerCase();
                        return fileName.endsWith(".json");
                    })
                    .forEach(path -> {
                        try {
                            Files.deleteIfExists(path);
                        } catch (IOException exception) {
                            throw new RuntimeException(exception);
                        }
                    });
        }
    }

    private static void deleteLegacySchemaJsonFiles() throws IOException {
        Files.deleteIfExists(EXPORT_DIRECTORY.resolve("schemas.json"));
        Files.deleteIfExists(EXPORT_DIRECTORY.resolve("asset_types_info.json"));
    }

    private static BsonArray buildAssetTypeOnlyStores() {
        BsonArray stores = new BsonArray();
        AssetEditorPlugin assetEditorPlugin = AssetEditorPlugin.get();
        if (assetEditorPlugin == null) {
            return stores;
        }

        List<Entry<String, AssetTypeHandler>> entries = new ArrayList<>(
                assetEditorPlugin.getAssetTypeRegistry().getRegisteredAssetTypeHandlers().entrySet()
        );
        entries.sort(Comparator.comparing(Entry::getKey));
        for (Entry<String, AssetTypeHandler> entry : entries) {
            if (!(entry.getValue() instanceof AssetStoreTypeHandler)) {
                stores.add(toAssetTypeOnlyStoreDocument(assetEditorPlugin, entry.getValue()));
            }
        }
        return stores;
    }

    private static BsonDocument toAssetTypeOnlyStoreDocument(@Nonnull AssetEditorPlugin assetEditorPlugin, @Nonnull AssetTypeHandler handler) {
        BsonDocument document = new BsonDocument();
        AssetEditorAssetType config = handler.getConfig();

        document.put("assetClass", BsonNull.VALUE);
        document.put("assetSimpleName", nullableString(config.id));
        document.put("keyClass", BsonNull.VALUE);
        document.put("path", nullableString(config.path));
        document.put("extension", nullableString(config.fileExtension));
        document.put("codecClass", BsonNull.VALUE);
        document.put("assetMapClass", BsonNull.VALUE);
        document.put("assetCount", new BsonInt32(-1));
        document.put("unmodifiable", BsonNull.VALUE);
        document.put("idProvider", BsonNull.VALUE);
        document.put("loadsAfter", new BsonArray());
        document.put("preAddedAssetCount", new BsonInt32(0));
        document.put("source", new BsonString("AssetTypeRegistry"));

        document.put("assetTypeId", nullableString(config.id));
        document.put("handlerClass", new BsonString(handler.getClass().getName()));
        document.put("rootPath", new BsonString(handler.getRootPath().toString()));
        document.put("icon", nullableString(config.icon));
        document.put("isColoredIcon", BsonBoolean.valueOf(config.isColoredIcon));
        document.put("editorType", config.editorType == null ? BsonNull.VALUE : new BsonString(config.editorType.name()));
        if (config.id != null) {
            Schema schema = assetEditorPlugin.getSchema(config.id + ".json");
            document.put("hasSchema", BsonBoolean.valueOf(schema != null));
            if (schema != null) {
                document.put("schemaFile", new BsonString(config.id + ".json"));
            }
        } else {
            document.put("hasSchema", BsonBoolean.FALSE);
        }
        return document;
    }

    private static BsonDocument toStoreDocument(@Nonnull AssetStore<?, ?, ?> store) {
        BsonDocument document = new BsonDocument();
        document.put("assetClass", new BsonString(store.getAssetClass().getName()));
        document.put("assetSimpleName", new BsonString(store.getAssetClass().getSimpleName()));
        document.put("keyClass", new BsonString(store.getKeyClass().getName()));
        document.put("path", store.getPath() == null ? BsonNull.VALUE : new BsonString(store.getPath()));
        document.put("extension", new BsonString(store.getExtension()));
        document.put("codecClass", new BsonString(store.getCodec().getClass().getName()));
        document.put("assetMapClass", new BsonString(store.getAssetMap().getClass().getName()));
        document.put("assetCount", new BsonInt32(store.getAssetMap().getAssetCount()));
        document.put("unmodifiable", BsonBoolean.valueOf(store.isUnmodifiable()));
        document.put("source", new BsonString("AssetRegistry"));

        Class<?> idProvider = store.getIdProvider();
        if (idProvider != null) {
            document.put("idProvider", new BsonString(idProvider.getName()));
        }

        BsonArray loadsAfter = new BsonArray();
        store.getLoadsAfter().stream().map(Class::getName).sorted().forEach(name -> loadsAfter.add(new BsonString(name)));
        document.put("loadsAfter", loadsAfter);

        List<?> preAddedAssets = store.getPreAddedAssets();
        int preAddedCount = preAddedAssets == null ? 0 : preAddedAssets.size();
        document.put("preAddedAssetCount", new BsonInt32(preAddedCount));
        if (preAddedAssets != null && !preAddedAssets.isEmpty()) {
            BsonArray preAddedKeys = new BsonArray();
            preAddedAssets.stream().map(asset -> keyToString(store, asset)).sorted().forEach(key -> preAddedKeys.add(new BsonString(key)));
            document.put("preAddedKeys", preAddedKeys);
        }

        return document;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    private static String keyToString(@Nonnull AssetStore<?, ?, ?> store, @Nonnull Object asset) {
        Function keyFunction = store.getKeyFunction();
        Object key = keyFunction.apply(asset);
        return key == null ? "null" : key.toString();
    }

    private static BsonValue nullableString(String value) {
        return value == null ? BsonNull.VALUE : new BsonString(value);
    }
}
